<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Machine Learning Programs</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        h3 {
            color: #2c3e50;
            margin-top: 20px;
        }
        pre {
            background-color: #f4f4f4;
            padding: 15px;
            border-radius: 5px;
            overflow-x: auto;
        }
        code {
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
        }
    </style>
</head>
<body>
    <h1>Machine Learning and Deep Learning Programs</h1>

    <h3>Aim: Write a program for object detection from the image/video</h3>
    <pre><code>
import cv2
import matplotlib.pyplot as plt

# Paths to model files (update these based on your file locations)
config_file = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
frozen_model = "frozen_inference_graph.pb"
labels_file = "labels.txt"
image_path = "3.png"  # Replace with your image path

# Load the pre-trained deep learning model
model = cv2.dnn_DetectionModel(frozen_model, config_file)
model.setInputSize(320, 320)
model.setInputScale(1.0 / 127.5)
model.setInputMean((127.5, 127.5, 127.5))
model.setInputSwapRB(True)

# Load class labels
with open(labels_file, "rt") as f:
    classLabels = f.read().strip().split("\n")

# Read and process the image
img = cv2.imread(image_path)
ClassIndex, Confidence, bbox = model.detect(img, confThreshold=0.5)

# Draw bounding boxes and labels
if len(ClassIndex) > 0:
    for ClassInd, conf, box in zip(ClassIndex.flatten(), Confidence.flatten(), bbox):
        cv2.rectangle(img, box, (255, 0, 0), 2)
        label_text = f"{classLabels[ClassInd - 1]}: {conf:.2f}"
        cv2.putText(img, label_text, (box[0], box[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (0, 255, 0), 2)

# Display the image
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.show()
    </code></pre>

    <h3>Aim: Implement Convolutional Neural Network for Digit Recognition on the MNIST Dataset</h3>
    <pre><code>
import numpy as np
import keras
from keras.datasets import mnist
from keras.models import Model
from keras.layers import Input, Conv2D, MaxPooling2D, Dropout, Flatten, Dense
from keras.utils import to_categorical
import matplotlib.pyplot as plt

# Load and preprocess data
(x_train, y_train), (x_test, y_test) = mnist.load_data()
img_rows, img_cols = 28, 28
x_train = x_train.reshape(-1, img_rows, img_cols, 1).astype('float32') / 255
x_test = x_test.reshape(-1, img_rows, img_cols, 1).astype('float32') / 255
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)

# Build model
inpx = Input((img_rows, img_cols, 1))
x = Conv2D(32, (3, 3), activation='relu')(inpx)
x = Conv2D(64, (3, 3), activation='relu')(x)
x = MaxPooling2D((2, 2))(x)
x = Dropout(0.25)(x)
x = Flatten()(x)
x = Dense(256, activation='sigmoid')(x)
out = Dense(10, activation='softmax')(x)
model = Model(inpx, out)
model.compile(optimizer='adadelta', loss='categorical_crossentropy', metrics=['accuracy'])

# Train and evaluate
model.fit(x_train, y_train, epochs=12, batch_size=500, validation_data=(x_test, y_test))
score = model.evaluate(x_test, y_test, verbose=0)
print("Test loss:", score[0], "Test accuracy:", score[1])

# Predict and visualize
y_pred = model.predict(x_test)
sample_index = 5
print("Predicted:", np.argmax(y_pred[sample_index]), "True:", np.argmax(y_test[sample_index]))
plt.imshow(x_test[sample_index].reshape(28, 28), cmap='gray')
plt.axis('off')
plt.show()
    </code></pre>

    <h3>Aim: Write a program to implement regularization to prevent the model from overfitting</h3>
    <pre><code>
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.linear_model import Lasso, Ridge
from sklearn import metrics

# Load dataset
dataset = pd.read_csv('Salary_Data.csv')
X = dataset.iloc[:, :-1].values  # Features
y = dataset.iloc[:, -1].values  # Target

# Split data into training and testing sets
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=1/3, random_state=0)

# Train Lasso model
lasso = Lasso().fit(X_train, y_train)
print("Lasso Train RMSE:", round(np.sqrt(metrics.mean_squared_error(y_train, lasso.predict(X_train))), 5))
print("Lasso Test RMSE:", round(np.sqrt(metrics.mean_squared_error(y_test, lasso.predict(X_test))), 5))

# Train Ridge model
ridge = Ridge().fit(X_train, y_train)
print("Ridge Train RMSE:", round(np.sqrt(metrics.mean_squared_error(y_train, ridge.predict(X_train))), 5))
print("Ridge Test RMSE:", round(np.sqrt(metrics.mean_squared_error(y_test, ridge.predict(X_test))), 5))
    </code></pre>

    <h3>Aim: Implement Feed-forward Neural Network and train the network with different optimizers and compare the results</h3>
    <pre><code>
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import LabelEncoder, OneHotEncoder, StandardScaler
from sklearn.compose import ColumnTransformer
from sklearn.metrics import confusion_matrix, accuracy_score
import tensorflow as tf

# Check TensorFlow version
print(f"TensorFlow Version: {tf.__version__}")

# Load dataset
dataset = pd.read_csv('DL_PRAC/Churn_Modelling.csv')

# Feature selection
X = dataset.iloc[:, 3:-1].values  # Independent variables
Y = dataset.iloc[:, -1].values   # Dependent variable

# Encode categorical data (Gender)
label_encoder = LabelEncoder()
X[:, 2] = label_encoder.fit_transform(X[:, 2])

# One-hot encode categorical data (Geography)
column_transformer = ColumnTransformer(
    transformers=[('encoder', OneHotEncoder(), [1])], remainder='passthrough'
)
X = np.array(column_transformer.fit_transform(X))

# Split dataset into training and testing sets
X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=0)

# Feature scaling
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

# Build the Artificial Neural Network (ANN)
ann = tf.keras.models.Sequential([
    tf.keras.layers.Dense(units=6, activation='relu'),  # Hidden layer 1
    tf.keras.layers.Dense(units=6, activation='relu'),  # Hidden layer 2
    tf.keras.layers.Dense(units=1, activation='sigmoid')  # Output layer
])

# Compile the ANN
ann.compile(optimizer='adadelta', loss='binary_crossentropy', metrics=['accuracy'])

# Train the ANN
ann.fit(X_train, Y_train, batch_size=32, epochs=100)

# Predict test set results
Y_pred = ann.predict(X_test)
Y_pred = (Y_pred > 0.5)  # Convert probabilities to binary predictions

# Display predicted vs actual values
print(np.concatenate((Y_pred.reshape(len(Y_pred), 1), Y_test.reshape(len(Y_test), 1)), axis=1))

# Evaluate model performance
conf_matrix = confusion_matrix(Y_test, Y_pred)
print("Confusion Matrix:")
print(conf_matrix)

accuracy = accuracy_score(Y_test, Y_pred)
print(f"Accuracy Score: {accuracy:.4f}")
    </code></pre>

</body>
</html>
