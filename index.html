<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Python Code in HTML</title>
    <!-- Include Prism.js for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
</head>
<body>
    <h1>Python Code Examples</h1>

    <!-- Python Code Block -->
    <pre><code class="python">
### Aim : Write a program for object detection from the image/video.
import cv2
import matplotlib.pyplot as plt
# Paths to model files (update these based on your file locations)
config_file = "ssd_mobilenet_v3_large_coco_2020_01_14.pbtxt"
frozen_model = "frozen_inference_graph.pb"
labels_file = "labels.txt"
image_path = "3.png"  # Replace with your image path
# Load the pre-trained deep learning model
model = cv2.dnn_DetectionModel(frozen_model, config_file)
model.setInputSize(320, 320)
model.setInputScale(1.0 / 127.5)
model.setInputMean((127.5, 127.5, 127.5))
model.setInputSwapRB(True)
# Load class labels
with open(labels_file, "rt") as f:
    classLabels = f.read().strip().split("\n")
# Read and process the image
img = cv2.imread(image_path)
ClassIndex, Confidence, bbox = model.detect(img, confThreshold=0.5)
# Draw bounding boxes and labels
if len(ClassIndex) > 0:
    for ClassInd, conf, box in zip(ClassIndex.flatten(), Confidence.flatten(), bbox):
        cv2.rectangle(img, box, (255, 0, 0), 2)
        label_text = f"{classLabels[ClassInd - 1]}: {conf:.2f}"
        cv2.putText(img, label_text, (box[0], box[1] - 10), cv2.FONT_HERSHEY_PLAIN, 1, (0, 255, 0), 2)
# Display the image
plt.imshow(cv2.cvtColor(img, cv2.COLOR_BGR2RGB))
plt.axis("off")
plt.show()

### Aim : Implement Convolutional Neural Network for Digit Recognition on the MNIST Dataset.
import numpy as np
import keras
from keras.datasets import mnist
from keras.models import Model
from keras.layers import Input, Conv2D, MaxPooling2D, Dropout, Flatten, Dense
from keras.utils import to_categorical
import matplotlib.pyplot as plt
# Load and preprocess data
(x_train, y_train), (x_test, y_test) = mnist.load_data()
img_rows, img_cols = 28, 28
x_train = x_train.reshape(-1, img_rows, img_cols, 1).astype('float32') / 255
x_test = x_test.reshape(-1, img_rows, img_cols, 1).astype('float32') / 255
y_train = to_categorical(y_train, 10)
y_test = to_categorical(y_test, 10)
# Build model
inpx = Input((img_rows, img_cols, 1))
x = Conv2D(32, (3, 3), activation='relu')(inpx)
x = Conv2D(64, (3, 3), activation='relu')(x)
x = MaxPooling2D((2, 2))(x)
x = Dropout(0.25)(x)
x = Flatten()(x)
x = Dense(256, activation='sigmoid')(x)
out = Dense(10, activation='softmax')(x)
model = Model(inpx, out)
model.compile(optimizer='adadelta', loss='categorical_crossentropy', metrics=['accuracy'])
# Train and evaluate
model.fit(x_train, y_train, epochs=12, batch_size=500, validation_data=(x_test, y_test))
score = model.evaluate(x_test, y_test, verbose=0)
print("Test loss:", score[0], "Test accuracy:", score[1])
# Predict and visualize
y_pred = model.predict(x_test)
sample_index = 5
print("Predicted:", np.argmax(y_pred[sample_index]), "True:", np.argmax(y_test[sample_index]))
plt.imshow(x_test[sample_index].reshape(28, 28), cmap='gray')
plt.axis('off')
plt.show()
    </code></pre>

    <!-- Include Prism.js for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-python.min.js"></script>
</body>
</html>
